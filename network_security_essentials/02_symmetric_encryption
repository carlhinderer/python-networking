-----------------------------------------------------------------------
| CHAPTER 2 - SYMMETRIC ENCRYPTION                                    |
-----------------------------------------------------------------------

- Symmetric Encryption Principles

    - Symmetric (aka 'secret key') encryption was the only type of encryption prior to the late 1970s.  It
        remains by far the most widely used method today.


    - A symmetric encryption scheme has 5 ingredients:

        1. Plaintext
        2. Encryption algorithm
        3. Secret key
        4. Ciphertext
        5. Decryption algorithm


    - 2 requirements for secure symmetric encryption

        1. The opponent should be unable to decrypt ciphertext even if they have a number of ciphertexts along
             with the plaintexts that produced them.

        2. The sender and receiver must have obtained copies of the secret key in a secure fashion and must keep
             the key secure.


    - The fact that the algorithm doesn't need to be secret has allowed manufacturers to develop low-cost chip
        implementations of data encryption algorithms.



- Cryptography

    - Cryptographic systems are generally classified along 3 independent dimensions:

        1. The type of operations used for transforming plaintext to ciphertext (substitutions and transpositions)
        2. The number of keys used
        3. The way in which the plaintext is processed (block cipher or stream cipher)


    - The process of attempting to discover the plaintext or key is called 'cryptanalysis'.

        - If an attacker has the ciphertext only (we assume they know the algorithm), they can attempt a brute
            force attack.  They can also attempt to apply statistical tests (based on knowledge of the English
            language or PL code structure, for instance).

        - If an attacker has both plaintext and ciphertext, they may be able to deduce the key.  This is an
            example of 'known plaintext'.

        - If an attacker can choose the plaintext to ecrypt, they can pick patterns that may reveal the structure
            of the key.  This is an example of 'chosen plaintext'.


    - An encryption scheme is 'computationally secure' if the ciphertext generated by the scheme meets one or both
        of these criterea.

        1. The cost of breaking the cipher exceeds the value of the encrypted information.
        2. The time required to break the cipher exceeds the useful lifetime of the information.



- Feistel Cipher Structure

    - Many symmetric block encryption algorithms have a structure first described by Horst Feistel (IBM) in 1973.

        - The inputs are a plaintext block with length 2w bits and a key K.

        - The plaintext block is divided into two halves, LE0 and RE0.

        - The two halves pass through n rounds of processing, then combine to produce the ciphertext block.
            Each round has different values for LE and RE and usually different subkey values.


    - The effectiveness of a symmetric block cipher depends on several parameters:

        1. Block size = The larger the block size, the better the security, but the slower the encryption/decryption
                          speed.  A block size of 128 bits is nearly universal.

        2. Key size   = Larger key size means greater security, but may reduce encryption/decryption speed.  The
                          most common length is 128 bits.

        3. Number of rounds = The higher the number, the better the security.  A typical size is from 10-16 rounds.

        4. Subkey generation algorithm

        5. Round function


    - Other factors in algorithm design are execution speed and ease of analysis.  We want an algorithm to be fast,
        and we want it to be easy to analyze for vulnerabilities.


    - Decryption is the same process in reverse order.



- Symmetric Block Encryption Algorithms

    - The most commonly used symmetric encryption algorithms are block ciphers.  A 'block cipher' processes the
        plaintext input in fixed-size blocks and produces a block of ciphertext of equal size for each plaintext
        block.


    - The 3 most important symmetric block ciphers are:

        - DES
        - Triple DES
        - AES



- DES (Data Encryption Standard)

    - Until AES was introduced in 2001, DES was the most widely used scheme.

    - Plaintext blocks are 64 bits, the key is 56 bits, and there are 16 rounds of processing.

    - The DES algorithm itself is the most studied encryption algorithm, and has never been broken.

    - The key length is a serious concern, however, and DES was broken by the EFF in 1998.



- Triple DES

    - 3DES was first developed for financial applications in 1985, and was incorporated into DES in 1999.


    - 3DES uses 3 keys and 3 executions of the DES algorithm.  It follows an encrypt-decrypt-encrypt sequence.
        This has no cryptographic significance, but it allows 3DES to decrypt data encrypted by DES.

        C = E(K3, D(K2, E(K1, P)))


    - With 3 keys, the effective key length is 168 bits.  This makes brute force attacks nearly impossible.

    - Ultimately, AES is intended to replace 3DES, but 3DES will remain an approved algorithm for the forseeable
        future.



- AES (Advanced Encryption Standard)

    - 3DES is very resistant to cryptanalysis, but it's performance is sluggish.  AES was created to have equal
        security strength with much better performance.

    - AES uses a block length of 128 bits and supports keys of 128, 192, or 256 bits.

    - It uses the Rijndael algorithm created by Belgian researchers.  The input block and keys are converted to a
        square matrix and transformed, so this is not a Feistel structure.  There are 10 rounds, each with one
        stage of permuation and 3 stages of substitution.



- Random and Pseudorandom Numbers

    - Many network security algorithms based on crpytography use random numbers.   For example,

        - Generation of keys for RSA and other public key algorithms
        - Generation of a stream key for symmetric stream ciphers
        - Generation of a symmetric key for use as a temporary session key
        - Use in key distribution scenarios such as Kerberos


    - There are 2 distinct (and not necessarily compatible) requirements for a sequence of random numbers: randomness
        and unpredictability.


    - For a sequence of numbers to have the property of randomness:

        - The distribution of bits should be uniform (there should be an equal frequency of 0s and 1s)
        - The numbers should be independent (no number can be inferred from the others)


    - For a sequence of numbers to have the property of unpredictability, each number is statistically independent of
        other numbers in the sequence.  Since numbers are often not truly random, but generated by some algorithm,
        care must be taken that an opponent cannot predict future elements of the sequence.


    - Cryptographic applications typically make use of algorithmic techniques for RNG, and these algorithms are
        deterministic, so the sequences are not statistically random.  However, they will pass many reasonable tests
        of randomness.

        - A TRNG (True RNG) algorithm takes a source that is effectively random as input, usually drawn from the 
            physical environment of the computer.  Examples of this include disk electrical activity, mouse movements,
            or the system clock.

        - A PRNG (Pseudo RNG) takes as input a fixed value called the 'seed' and produces a sequence of output bits
            using a deterministic algorithm.  Any attacker with the seed can produce the entire bit stream.  A PRNG
            produces an open-ended sequence of bits to a symmetric stream cipher.

        - A PRF (Pseudorandom Function) is a PRNG that produces a fixed-length string of bits.  Examples are
            symmetric encryption keys and nonces.


    - Cryptographic PRNGs have been the subject of much research, and a wide variety of algorithms have been developed.
        The algorithms fall into 2 categories:

        1. Purpose-built algorithms = These have been designed solely for the purpose of generating pseudorandom bit
                                        streams.  RC4 is an example of one that is designed for use in a stream cipher.

        2. Based on existing crpytographic algorithms = These use existing cryptographic algorithms, such as symmetric
                                                          block ciphers, asymmetric ciphers, and hash functions to
                                                          generate random numbers.



- Stream Ciphers

    - A 'block cipher' processes the input one block of elements at a time, producting an output block for each input
        block.  A 'stream cipher' processes the input elements continuously, producing output one element at a time as
        it goes along.

    - Block ciphers are far more common, but there are some applications where stream ciphers are more appropriate.


    - A typical stream cipher encrpyts plaintext one byte at a time.  A key is input to a pseudorandom bit generator
        that produces a stream of 8-bit numbers that are apparently random.  The output of the generator, called a
        'keystream', is XOR'ed one byte at a time with the plaintext stream.  Decryption requires the use of the
        same pseudorandom sequence.


    - Design considerations:

        - The encryption sequence should have a large period before it eventually repeats.

        - The keystream should be as close to a true random number stream as possible.

        - The input key should be sufficiently long (at least 128 bits) to make brute force attacks infeasible.


    - One advantage of stream ciphers is that they are faster and use less code.  This advantage has diminished in
        recent years, however, with the introduction of AES and the Intel AES Instruction Set that adds machine 
        instructions.

    - One advantags of block ciphers is that you can reuse keys.  With stream ciphers, if you use the same key twice
        than cryptanalysis becomes much simpler.

    - For applications that require encryption/decryption of a stream of data (ie a data communications channel or
        a browser/web link), a stream cipher might be a better alternative.  For applications that deal with blocks of
        data (ie file transfer, email, database), block ciphers may be more appropriate.  However, either type of cipher
        can be used in virtually any application.



- The RC4 Algorithm (Rivest Cipher 4)

    - RC4 is a stream cipher that was designed in 1987 by Ron Rivest for RSA Security.  It is a variable key-size cipher
        with byte-oriented operations.  8-16 machine operations are required per byte, so it is very fast.  RC4 is used in
        the SSL/TLS standards, and is also used in WEP/WPA.


    - The algorithm is very simple.  First, a variable length key is used to initialized a 256-bit state vector S, which
        always contains all 8-bit numbers 0-255.

        # Initialization
        S = []
        T = []
        for i in range(256):
            S[i] = i
            T[i] = K[i % keylen]


    - Then, we use T to product the initial permutation of S:

        # Initial permutation of S
        j = 0
        for i in range(256):
            j = (j + S[i] + T[i]) mod 256
            S[i], S[j] = S[j], S[i]


    - Once the S vector is initialized, the input key is no longer used.  To generate the stream:

        # Stream generation
        i = j = 0
        while(True):
            i = (i + 1) % 256
            j = (j + S[i]) % 256
            S[i], S[j] = S[j], S[i]
            t = (S[i] + S[j]) % 256
            k = S[t]



- Cipher Block Modes of Operation

    - A symmetric block cipher processes one block of data at a time.  With DES and 3DES, b=64, and with AES b=128.
        For longer amounts of plaintext, the plaintext is broken into b-bit blocks.  To apply a block cipher in a
        variety of applications, 5 modes of operation have been defined.  Each of these modes can be used with any
        symmetric block cipher, including 3DES and AES.


    - (ECB) Electronic Codebook Mode

        - Plaintext is handled b bits at a time, and each block of plaintext is encrypted using the same key.

        - If the same block appears more than once, it always produces the same ciphertext, so this may not be
            secure for longer messages.


    - (CBC) Cipher Block Chaining Mode

        - The input to the algorithm is the XOR of the current plaintext block and the preceding ciphertext block.
            The same key is used for each block.

        - Repeating patterns are not exposed.

        - For decryption, each cipher block is passed through the decryption algorithm.  The result is XORed with the
            preceding ciphertext block to produce the plaintext block.

        - To produce the first block of ciphertext, an IV (Initialization Vector) is XORed with the first block of
            plaintext.  On decryption, the IV is XORed with the output of the decryption algorithm to recover the
            first block of plaintext.  The IV must be known to both the sender and receiver, and should be protected
            as well as the key.


    - (CFB) Cipher Feedback Mode

        - It is possible to convert any block cipher into a stream cipher using the CFB mode.  A stream cipher 
            eliminates the need to pad a message to be an integral number of blocks.  It can also operate in real time.
            If a character stream is being transmitted, each character can be encrypted and transmitted immediately
            using a character-oriented stream cipher.

        - It is desirable in a stream cipher that the ciphertext be the same length as the plaintext (ie 8 bits for
            a character).  If more than 8 bits are used, transmission capacity is wasted.

        - The input to the encryption function is a b-bit shift register S that is initially set to some IV.  The leftmost
            bits of the output of the encryption function are XORed with the first unit of plaintext to output the first
            unit of ciphertext, which is then transmitted.  In addition, the shift register is shifted by s bits.  This
            process continues until all plaintext units have been encrypted.


    - (CTR) Counter Mode

        - Counter Mode interest has increased recently with applications to ATM and IPSec.

        - A counter equal to the plaintext block size is used.  The counter value should be different for each plaintext
            block that is encrypted.  Typically, the counter is initialized to some value and then incremented by 1 for
            each subsequent block.

        - For encryption, the counter is encrypted and then XORed with the plaintext block to produce the ciphertext
            block.  There is no chaining.

        - For decryption, the same sequence of counter values is used, each encrypted counter XORed with a ciphertext
            block to recover the corresponding plaintext block.

        - There are several advantages to using CTR.  Since there is no chaining, encryption can be done in parallel in
            either hardware or software.  Preprocessing can be done to prepare the output of the encryption boxes that
            will feed into the XOR.  Blocks can also be accessed reandomly.